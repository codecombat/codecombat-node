/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import { CodeCombat } from "@fern-api/codecombat";
import urlJoin from "url-join";
import * as serializers from "../../../../serialization";
import * as errors from "../../../../errors";
import URLSearchParams from "@ungap/url-search-params";

export declare namespace Users {
    interface Options {
        environment?: environments.CodeCombatEnvironment | string;
        credentials: core.Supplier<core.BasicAuth>;
    }
}

export class Users {
    constructor(private readonly options: Users.Options) {}

    /**
     * Creates a `User`.
     * #### Example
     * ```javascript
     * url = 'https://codecombat.com/api/users'
     * json = { email: 'an@email.com', name: 'Some Username', role: 'student' }
     * request.post({ url, json, auth })
     * ```
     *
     */
    public async create(request: CodeCombat.CreateUserRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.CodeCombatEnvironment.Production, "/users"),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.CreateUserRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a `User`.
     */
    public async get(handle: string, request: CodeCombat.GetUserRequest = {}): Promise<CodeCombat.UserResponse> {
        const { includePlayTime } = request;
        const _queryParams = new URLSearchParams();
        if (includePlayTime != null) {
            _queryParams.append("includePlayTime", includePlayTime);
        }

        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.CodeCombatEnvironment.Production, `/users/${handle}`),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Modify name of a `User`
     */
    public async update(handle: string, request: CodeCombat.UpdateUserRequest): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.CodeCombatEnvironment.Production, `/users/${handle}`),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.UpdateUserRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of `Classrooms` this user is in (if a student) or owns (if a teacher).
     */
    public async getClassrooms(
        handle: string,
        request: CodeCombat.GetClassroomsRequest = {}
    ): Promise<CodeCombat.ClassroomResponseWithCode[]> {
        const { retMemberLimit } = request;
        const _queryParams = new URLSearchParams();
        if (retMemberLimit != null) {
            _queryParams.append("retMemberLimit", retMemberLimit.toString());
        }

        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/classrooms`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.users.getClassrooms.Response.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Set the user's hero.
     */
    public async getHero(handle: string, request: CodeCombat.GetHeroRequest = {}): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/hero-config`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.GetHeroRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Set the user's aceConfig (the settings for the in-game Ace code editor), such as whether to enable autocomplete.
     */
    public async setAceConfig(handle: string, request: CodeCombat.SetAceConfig = {}): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/ace-config`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.SetAceConfig.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Adds an OAuth2 identity to the user, so that they can be logged in with that identity. You need to send the OAuth code or the access token to this endpoint. 1. If no access token is provided, it will use your OAuth2 token URL to exchange the given code for an access token. 1. Then it will use the access token (given by you, or received from step 1) to look up the user on your service using the lookup URL, and expects a JSON object in response with an `id` property. 1. It will then save that user `id` to the user in our db as a new OAuthIdentity. #### Example ```javascript url = `https://codecombat.com/api/users/${userID}/o-auth-identities` OAUTH_PROVIDER_ID = 'xyz' json = { provider: OAUTH_PROVIDER_ID, accessToken: '1234' } request.post({ url, json, auth}, (err, res) => {
     *   console.log(res.body.oAuthIdentities) // [ { provider: 'xyx', id: 'abcd' } ]
     * }) ``` In this example, we call your lookup URL (let's say, `https://oauth.provider/user?t=<%= accessToken %>`) with the access token (`1234`). The lookup URL returns `{ id: 'abcd' }` in this case, which we save to the user in our db.
     *
     */
    public async addOAuthIdentity(
        handle: string,
        request: CodeCombat.AddOAuthIdentityRequest
    ): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/o-auth-identities`
            ),
            method: "POST",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.AddOAuthIdentityRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Grants a user premium access to the "Home" version up to a certain time.
     * #### Example
     * ```javascript
     * url = `https://codecombat.com/api/users/${userID}/subscription`
     * json = { ends: new Date('2017-01-01').toISOString() }
     * request.put({ url, json, auth }, (err, res) => {
     *   console.log(res.body.subscription) // { ends: '2017-01-01T00:00:00.000Z', active: true }
     * })
     * ```
     *
     */
    public async updateSubscription(
        handle: string,
        request: CodeCombat.UpdateSubscriptionRequest
    ): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/subscription`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.UpdateSubscriptionRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * If the user already has a premium access up to a certain time, this shortens/revokes his/her premium access. If the ends is less than or equal to the current time, it revokes the subscription and sets the end date to be the current time, else it just shortens the subscription. #### Example ```javascript url = `https://codecombat.com/api/users/${userID}/shorten-subscription` json = { ends: new Date().toISOString() } request.put({ url, json, auth }, (err, res) => {
     *   console.log(res.body.subscription.active) // false
     * }) ```
     *
     */
    public async shortenSubscription(
        handle: string,
        request: CodeCombat.ShortenSubscriptionRequest
    ): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/shorten-subscription`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.ShortenSubscriptionRequest.jsonOrThrow(request, {
                unrecognizedObjectKeys: "strip",
            }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Grants a user access to the "Classroom" version up to a certain time.
     * Sets their role to "student".
     * #### Example
     * ```javascript
     * url = `https://codecombat.com/api/users/${userID}/license`
     * json = { ends: new Date('2017-01-01').toISOString() }
     * request.put({ url, json, auth }, (err, res) => {
     *   console.log(res.body.license) // { ends: '2017-01-01T00:00:00.000Z', active: true }
     * })
     * ```
     *
     */
    public async grantLicense(
        handle: string,
        request: CodeCombat.GrantLicenseRequest
    ): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/license`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.GrantLicenseRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * If the user already has access to the "Classroom" version up to a certain time, this shortens/revokes his/her access. If the ends is less than or equal to the current time, it revokes the enrollment and sets the end date to be the current time, else it just shortens the enrollment. #### Example ```javascript url = `https://codecombat.com/api/users/${userID}/shorten-license` json = { ends: new Date().toISOString() } request.put({ url, json, auth }, (err, res) => {
     *   console.log(res.body.license.active) // false
     * }) ```
     *
     */
    public async shortenLicense(
        handle: string,
        request: CodeCombat.ShortenLicenseRequest
    ): Promise<CodeCombat.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/users/${handle}/shorten-license`
            ),
            method: "PUT",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
            body: await serializers.ShortenLicenseRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
            });
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Redirects to `/users/{handle}` given a unique, identifying property
     */
    public async findUser(property: string, value: string): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatEnvironment.Production,
                `/user-lookup/${property}/${value}`
            ),
            method: "GET",
            headers: {
                Authorization: await this._getAuthorizationHeader(),
            },
            contentType: "application/json",
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatTimeoutError();
            case "unknown":
                throw new errors.CodeCombatError({
                    message: _response.error.errorMessage,
                });
        }
    }

    private async _getAuthorizationHeader() {
        const bearer = await core.Supplier.get(this.options.credentials);
        if (credentials != null) {
            return core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(credentials));
        }

        return undefined;
    }
}
