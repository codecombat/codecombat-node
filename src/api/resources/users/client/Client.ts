/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import { CodeCombatApi } from "@fern-api/codecombat";
import urlJoin from "url-join";
import * as serializers from "../../../../serialization";
import * as errors from "../../../../errors";

export declare namespace Client {
    interface Options {
        environment?: environments.CodeCombatApiEnvironment | string;
        credentials?: core.Supplier<core.BasicAuth>;
    }
}

export class Client {
    constructor(private readonly options: Client.Options) {}

    /**
     * Creates a `User`.
     */
    public async create(request: CodeCombatApi.CreateUserRequest): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(this.options.environment ?? environments.CodeCombatApiEnvironment.Production, "/users"),
            method: "POST",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.CreateUserRequest.json(request),
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a `User`.
     */
    public async get(handle: string, request: CodeCombatApi.GetUserRequest = {}): Promise<CodeCombatApi.UserResponse> {
        const { includePlayTime } = request;
        const _queryParams = new URLSearchParams();
        if (includePlayTime != null) {
            _queryParams.append("includePlayTime", includePlayTime);
        }

        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}`
            ),
            method: "GET",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Modify name of a `User`
     */
    public async modifyUser(
        handle: string,
        request: CodeCombatApi.ModifyUserRequest
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.ModifyUserRequest.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Returns a list of `Classrooms` this user is in (if a student) or owns (if a teacher).
     */
    public async getClassrooms(
        handle: string,
        request: CodeCombatApi.GetUserClassroomsRequest = {}
    ): Promise<CodeCombatApi.ClassroomResponseWithCode[]> {
        const { retMemberLimit } = request;
        const _queryParams = new URLSearchParams();
        if (retMemberLimit != null) {
            _queryParams.append("retMemberLimit", retMemberLimit.toString());
        }

        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/classrooms`
            ),
            method: "GET",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            queryParameters: _queryParams,
        });
        if (_response.ok) {
            return await serializers.users.getClassrooms.Response.parse(
                _response.body as serializers.users.getClassrooms.Response.Raw
            );
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Set the user's hero.
     */
    public async setHero(
        handle: string,
        request: CodeCombatApi.SetHeroRequest = {}
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/hero-config`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.SetHeroRequest.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Set the user's aceConfig (the settings for the in-game Ace code editor), such as whether to enable autocomplete.
     */
    public async setAceConfig(
        handle: string,
        request: CodeCombatApi.SetAceConfigRequest = {}
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/ace-config`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.SetAceConfigRequest.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Adds an OAuth2 identity to the user, so that they can be logged in with that identity. You need to send the OAuth code or the access token to this endpoint.
     * 1. If no access token is provided, it will use your OAuth2 token URL to exchange the given code for an access token.
     * 2. Then it will use the access token (given by you, or received from step 1) to look up the user on your service using the lookup URL, and expects a JSON object in response with an `id` property.
     * 3. It will then save that user `id` to the user in our db as a new OAuthIdentity.
     *
     */
    public async addOauth2Identity(
        handle: string,
        request: CodeCombatApi.AddOauth2IdentityRequest
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/o-auth-identities`
            ),
            method: "POST",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.AddOauth2IdentityRequest.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Grants a user premium access to the "Home" version up to a certain time. ```
     *
     */
    public async grantPremiumAccess(
        handle: string,
        request: CodeCombatApi.Subscription
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/subscription`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.Subscription.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * If the user already has a premium access up to a certain time, this shortens/revokes his/her premium access.
     * If the ends is less than or equal to the current time, it revokes the subscription and sets the end date to be the current time, else it just shortens the subscription.
     *
     */
    public async shortenSubscription(
        handle: string,
        request: CodeCombatApi.Subscription
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/shorten-subscription`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.Subscription.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Grants a user access to the "Classroom" version up to a certain time.
     * Sets their role to "student".
     *
     */
    public async grantClassroomAccess(
        handle: string,
        request: CodeCombatApi.Subscription
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/license`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.Subscription.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * If the user already has access to the "Classroom" version up to a certain time, this shortens/revokes his/her access.
     * If the ends is less than or equal to the current time, it revokes the enrollment and sets the end date to be the current time, else it just shortens the enrollment.
     *
     */
    public async shortenLicense(
        handle: string,
        request: CodeCombatApi.Subscription
    ): Promise<CodeCombatApi.UserResponse> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/${handle}/shorten-license`
            ),
            method: "PUT",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
            body: await serializers.Subscription.json(request),
        });
        if (_response.ok) {
            return await serializers.UserResponse.parse(_response.body as serializers.UserResponse.Raw);
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Redirects to `/{handle}` given a unique, identifying property
     */
    public async lookup(property: string, value: string): Promise<void> {
        const _response = await core.fetcher({
            url: urlJoin(
                this.options.environment ?? environments.CodeCombatApiEnvironment.Production,
                `/users/user-lookup/${property}/${value}`
            ),
            method: "GET",
            headers: {
                Authorization: core.BasicAuth.toAuthorizationHeader(await core.Supplier.get(this.options.credentials)),
            },
        });
        if (_response.ok) {
            return;
        }

        if (_response.error.reason === "status-code") {
            throw new errors.CodeCombatApiError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CodeCombatApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CodeCombatApiTimeoutError();
            case "unknown":
                throw new errors.CodeCombatApiError({
                    message: _response.error.errorMessage,
                });
        }
    }
}
